# IV. Inheritance

## 4.1 Private, public and protected inheritance

**Inheritance** - Наследование
```cpp
struct Base {
	void f() {std::cout << 1; }
	int a = 0;
};

struct Derived: public Base {
	void g() {std::cout << 2;}
};

int main() {
	Derived d;
	d.f();
	d.a = 1;
}
```
Структура `Derived` - наследник класса `Base` 
```cpp
class Base {
public:
	void f() {std::cout << 1; }
	int a = 0;
};

class Derived: Base {
	void g() {std::cout << 2;}
};
```
Теперь `Derived d; d.f()` не будет работать, потому что наследование без указания не дает прав к тем полям.  
В отличие от классов, структуры наследуются по умолчанию публично.  

Есть приватное наследование: никто кроме членов класса Derived и друзей класса Derived не имеет доступа к Base  
*Публичное наследование* - контракт: я частный случай другого класса   
*Приватное наследование* - контракт: только я знаю что я частный случай и реализован с помощью родителя   

Есть поля `protected`, которые доступны членам и друзьям класса, а также членам и друзьям  наследников.  
Есть наследование `protected`: только вы и ваши наследники  и друзья имеют доступ к родителю, но остальные не имеют.  

Наследование транзитивно  
```cpp
class Base {
    friend class Third;
public:	
    void f() {std::cout << 1; }
private:
    int a = 0;
protected:
    int b = 1;
};
class Derived: protected Base {
public:
    void g() {std::cout << 2;}
};

class Third: public Derived {
public:
    void h() {
        ::Base b;
        b.a = 1;
    }
}
```
Есть разница между видимостью/наличием поля и доступностью. У `Third` и `Derived` есть видимость всех полей и методов `Base`, но нет доступности к приватным полям, но так как `Third` друг класса `Base`, поэтому у него есть доступ к приватном полю `a`    

При прохождении к базовому классу берется минимум наследования  
Вопрос имени функции решается до того как дается доступ, поэтому если есть две функции `f()` в `private` и в `public`, то будет ошибка при обращении, хотя и нет доступа к `f`  
```cpp
class Granny {
public:
    int a = 0;
    void f(double){}
};

class Mom: public Granny {
private:
    int a = 1;
    void f(int){}
};

class Son: public Mom {

};

int main(){
    Mom m;
    // std::cout << m.a; // будет CE, но при этом в Mom есть поле 0
    std::cout << m.Granny::a;
    m.f(0.0) // Дальше он не ищет сразу видит что CE так как у 
             // Mom есть видимая но не доступная, а f у бабушки она не попадает в кандидаты
}
```
Важно где писать `using`: в `private` или `public` секции, от этого зависит будет ли оно доступно


Если `Mom` приватно наследуемо от `Granny`, то в сыне нельзя использовать `Granny x;` а можно только `::Granny x;` потому что внутренне нельзя обратится изза приватности
