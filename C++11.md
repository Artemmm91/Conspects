## 5.8) Virtual functions with virtual inheritance

Пусть отнаследованы так:

Son <--- Mother <-----(virtual) Granny
Son <--- Father <-----(virtual) Granny

У Granny `virtual void foo()`, а значит все классы полиморфны

В памяти это лежит так:

{  vptr  }{  m  }{  vptr  }{  f  }{  s  }|{  vptr  }{  g  }

vtable выглядит для Mother-in-Son выглядит так:

{  virtual_offset  }{  top_offset  }{  typeinfo  }{  &foo  }

Где `virt_offset` - ссылка на место где вирутальные предки (они после всех подряд), 
`top_offset` - сдвиг показывающий как далеко вы от начала всего объекта (до своего `vptr`) (чтобы делать dynamic cast)
`typeinfo` - показывает тип, с учетом наследования
`&foo` - ссылка на свою функцию foo

## 5.9) Some problems with dynamic dispatching

То есть проблемы с выбором функции.

```
struct Base {
    virtual void f(int x = 1){
        std::cout << "Base" << x << "\n";
    }
}

struct Derived: public Base {
    void f(int x = 2) override{
        std::cout << "Derived" << x << "\n";
    }
}

int main(){
  const Base& = Derived();
  b.f();
}
```





