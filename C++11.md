## 5.8) Virtual functions with virtual inheritance

Пусть отнаследованы так:

Son <--- Mother <-----(virtual) Granny
Son <--- Father <-----(virtual) Granny

У Granny `virtual void foo()`, а значит все классы полиморфны

В памяти это лежит так:

{  vpt  }{  m  }{  vptr  }{  f  }{  s  }|{  vptr  }{  g  }

vtable выглядит для Mother-in-Son выглядит так:

{  virtual_offset  }{  top_offset  }{  typeinfo  }{  &foo  }

Где `virt_offset` - ссылка на место где вирутальные предки (они после всех подряд), 
`top_offset` - сдвиг показывающий как далеко вы от начала всего объекта (до своего `vptr`) (чтобы делать dynamic cast)
`typeinfo` - показывает тип, с учетом наследования
`&foo` - ссылка на свою функцию foo

## 5.9) Some problems with dynamic dispatching

То есть проблемы с выбором функции.

```
struct Base {
    virtual void f(int x = 1) const {
        std::cout << "Base" << x << "\n";
    }
};

struct Derived: public Base{
    void f(int x = 2) const override{
        std::cout << "Derived" << x << "\n";
    }
};

int main(){
  const Base& b = Derived();
  b.f();
}
```

Почему b.f() вызовет "Derived 1"? Потому что компилятор не знает в какую версию мы попадем на самом деле, поэтому компилятор подставляет аргумент по умолчанию 1, поэтоvу он возьмет аргумент по умолчанию у Base (потому что тип Base). Но в Run-Time мы то знаем что функция virtual поэтому попадем в Derived.f() но вызовется 1

```
struct Base {
    Base() {
        f(0);
    }
    virtual void f(int) const {
        std::cout << "Base" << x << "\n";
    }
};

struct Derived: public Base{
    Derived(){
        f(1);
    }
    void f(int) const override{
        std::cout << "Derived" << x << "\n";
    }
};

int main(){
  const Base& b = Derived();
  b.f(2); // будет Derived 1
}
```

В конструкте родителя вызывая виртуальную функцию вызовется функция родителя, потому что по факту еще нет наследника. А если бы у Base была чисто вирутальная функция, то было бы RE (так же и в деструкторе, но не остальных функциях).

```
struct Base {
    virtual void f();
};

int main(){
    Base b;
}

```

А тут будет лажа, в том что виртуальная функция должная определится, чтобы можно было сделать ссылку в vtable, так как тип полиморфый

# VI. Templates
## 6.1) Idea of template

```
int mymax(int a, int b) {
    return a > b ? a : b;
}

double mymax(double a, double b) {
    return a > b ? a : b;
}
```
Одна и та же функция может быть для разных типов
```
template <typename T>
T mymax(T a, T b) {
    return a > b ? a : b;
}
```
Принимает объекты типа T возвращает объект типа T
Ассоциация: шаблоны - уровень кванторов: для любого типа Т, функция чтото там делает. Для компилятора a и b - понятно что, но Т - непонятно что, это мета-переменная.
Компилятор компилирует в два этапа: 1) проверяет синтаксическую корректность (пока не знает Т) 2) корректнотсь с Т проверяется в конкретном вызове:
```
mymax(1, 2);
mymax(std::cout, std::cout);
```
С первой строчкой все хорошо, со второй проблемы - потому что нельзя сравнивать потоки - неопределена операция > - CE

```
int (*pfi)(int, int) = &mymax<int>;
double (*pfd)(double, double) = &mymax<double>;
std::cout << (int*)pfi << ' ' << (int*)pfd << '\n';
```
Адреса у функций разные, и отличаются существенно, потому что функции разные.

```
// шаблонные класс
template <typename T>
struct S {
    ... // здесь можно использовать Т
};

// шаблонные алиасы
// since C++11
template <typename T>
using umap<T> = std::unordered_map<T, T>;
// umap<int> um;

//шаблонные переменные
//since c++14
template <typename T>
T pi = 3.14;
```

Когда пишется `template <typename T>` после должно идти объявление (класса, функции, алиаса, переменной). Шаблоны можно объявлять только за пределеами кода, во внешней части функции/итд. Можно написать `template <typename T, typename U>`

```
template<typename U>
struct S{
    U x;
    
    template<typename T>
    void f(T a, U b);
};


template<typename T>
template<typename U>
// нельзя template <typename T, typename U>
void S<U>::f(T a, T b){}

int main(){
    S<int> s;
    s.f("abc", 20);
}
```

Пример использования шаблонов в классах и функциях класса
При этом можно писать `template <class T>` и это то же самое, но вводит в заблуждение что используется только классы (хотя это не так). Но по код стайлу надо писать `template <typename T>`
