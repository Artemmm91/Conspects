# Введение в программирование

# Introduction
## 1.1) General info
	
Плюсы производительны, сложны, но лучше для утонченной настройки, при этом нужно следить за большим числом вещей (памятью, итд)

Применение плюсов: большая часть яндекса, гугл, серверные/вычислительные части, ОС, фотошопы, редакторы, биржи, игры

Плюсы произошли от С, Бьерн Страуструп - Создатель. 
Существует Комитет по стандартизации который рассматривает предложения по улучшению языка, выпускается раз в три года. 
Мы будем по С++ 17. Важная веха в развитии - С++ 11, который сильно отличается от предыдущей версии (С++ 03). 
Версии: 98, 03, 11, 14, 17, 20(будет)
	
## 1.2) Первая программа

Терминал: ~ - домашняя директория  
`pwd` - полное название директории (print working directory)  
`ls` - все элементы текущей директории  
`cd x` - переход в x из текущей папки  
`cd ..` - переход верх  
`сd` -  - переход в предыдущую папку  
`clear` - очистить экран  
`mkdir х` - новая папка х  
`rm` - удалить  
`mv` - переместить (также переименовать)  
`cp` - скопировать  
`vim test.cpp` - создать в vime новый файл:  

```
#include <iostream>
int main(){
	int x;
	std::cin >> x;
	std::cout << x + 5 << '\n';
}
```

Чтобы выйти из vim `:wq enter` (в режиме команд (esc))  
Чтобы начать печатать надо нажать `i` (состояние insert)  

`using namespace` - плохо, потому что добавляет в область видимости много ненужного мусора, например стандартные функции (min) поэтому в больших проектах не используется  
Но можно: `using std::cin;` или `using std::cout;` и потом без `std::` писать эти команды  

Компилируемый язык - чтобы выполнить программу нужно превратить ее в исполняемый файл а потом запустить.
Интерпретируемый язык может работать в формате - выполнил, продолжил работать дальше. Транслирует непосредственно команду в машинный код.  
В этом проблема интерпретируемых языков, потому что большие коды отлаживать сложно.  

Как делать компиляцию в vim:  
`g++ test.cpp` - компиляция, создается a.out  
`./a.out` - запуск файла, пишется через ./ иначе может подумать что надо искать его в папке исполняемых файлов  

Кроме g++ есть еще компиляторы: clang, msvc (компилятор от майкрософта, но работает не по стандарту, поэтому плох)  

Когда пишите в командой строке есть настройки (ключи), например `ls -l: ls` это команда, а -l ключ показывающий больше инфы(с датой).  
С компилятором есть свои ключи:  
`g++ - -std=c++17 test.cpp` - ключ стандарта языка

## 1.3) Kinds of errors and UB (undefined behaviour)

**CE** - ошибка компиляции (compile-time error)  
Компилятор разбивает код на токены - части. Например `std`, `::`, `cin`, `>>`, `x`, `;`.   
В токен символы набираются по принципу: добираем символы пока осмысленно (исключение - шаблоны в шаблоне).   
Если на этом этапе компилятор не поймет символ - то будет лексическая ошибка.   
Далее он разбивает токены по группам (по ;) и смотрит на синтаксис `a + + b = 1;`.   
Две основные проблемы - неопределенность и неоднозначность.  
**RE** - runtime error, ошибка в работе программы.  
Основная ошибка - **segmentation fault (core dumped)** - программа обращается к памяти, которая ей не принадлежит.  
Происходит при переполнении стека, удалении не того элемента, за границы массива, итд.   

**UB** - может произойти что угодно вообще.  
Компилятор работает в предположении что ввод корректен, поэтому во время UB компилятор предполагает что все норм и может случится неожиданное.  
Например, оптимизатор может подумать что условие всегда выполняется потому что переполнения не будет (хотя оно может быть) и например не выполнять некоторые условия сравнения.  

**Unspecified behaviour** - поведение, не меняющее результат, но при этом неизвестное и зависит от компилятора. Например f(g(), h()); - неизвестно кто будет раньше g() или h().  

**Link error** - неопределенная ссылка на объект.

## 1.4) Definitions and declarations

Объявлять можно:  
переменные: `type id;`  
функции: `type id(type id1, …);`   
свой тип: `class(struct, union) id;`  
псевдоним(alias) `using mymap = std::map<…>;`  
`using` - вместо typedef, define  

Любое объявление переменной - ее определение, если не сделать extern  
Для функции, классов(и подобных) можно просто объявлять, а определение уже в {теле}  
**One definition rule** - каждая вещь должна быть единственный раз определена, но есть исключения (классы и namespace).  
Но объявить можно несколько раз (int f(x); int f(x);)  
