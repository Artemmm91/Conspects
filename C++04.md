## 2.3 Functions with default arguments
```
void f(int x, int y = 0){
    ...  // все дефолтные аргументы после идут после обычных переменных
}

f(1);
f(1, 5);
```
При этом теперь нельзя будет будет перегружать `void f(int x);`  

При этом существует возможность функции от нескольких переменных
```
#include <stdarg.h>

int f(int n_args, ...){

}

void f(…);
void f(int);
void f(double);

f(1); // функция с многими элементами будет вызвана в последнюю очередь, у нее меньший приоритет
```
## 2.4 References
```
void swap(int x, int y){
    int t = x;
    x = y;
    y = t;
}

int main() {
    int x = 1;
    int y = 2;
    swap(x, y); // ничего не поменяется
}
```
Потому что при вызове функции они локально скопировались, но ничего не произошло  
Чтобы они обменялись например можно сделать так:  
```
void swap(int* x, int* y){
    int t = *x;
    *x = *y;
    *y = t;
}
```
Тогда будут передаваться адреса переменных, поэтому значения поменяются    
Это С-style (также в scanf нужно передавать &x)  

`vector<int> v = {1, 2, 3, 4, 5};`
`vector<int> vv = v;` эту запись можно понимать двояко. Например vv - другой вектор, с таким же содержанием как и v. А можно понимать, что vv - другое название для веткора v(и теперь меняя v меняется vv).  
То есть имена и объекты. Можно разными способами назвать один объект.  
По дефолту это будет копия, а чтобы по-другому назвать, нужно использовать понятие ссылок.  
```
vector<int>& vv = v;

type a;
type b = a; // копия объекта, уже другой объект
type& c = a; // название того же объекта
```
В плюсах объекты удаляются вручную, поэтому мы сами должны вручную писать ссылки, чтобы компилятор понимал на этапе компиляции сколько ссылок будет на объект.    При выходе из области видимости компилятор не будет уничтожать объект, а будет забывать ссылку.
```
void swap(int& x, int& y){
	int t = x;
	x = y;
	y = t;
}
``` 
Функция принимает новые названия для старых переменных, поэтому когда мы делаем swap, все работает.  

Например:  
```
int x = 1;
int& y = x;
int& z = y; 
// y - просто другое название x, поэтому z - тоже другое название x
int a = 0;
z = a;
++a;
// теперь x, y, z - равны 0, а равно 1
sizeof(y) // столько же сколько x, так не узнаем размер ссылки
std::vector<int&> v; // Так нельзя сделать, потому что вектор хочет делать указатели на это 
                     // поэтому образуется int&* а такого типа не существует, однако можно делать ссылку на указатель:
int* p = &x;
int*& pp = p; // другое название указателя
```
Нельзя делать ссылку на ссылку. Также ссылка должна быть всегда инициализирована (нельзя `int& x;`)  
И нельзя сделать чтобы ссылка ссылалась на другой объект.  
И нельзя инициализировать ссылку с rvalue, то есть нельзя например `swap(1, 2);`
Потому что нельзя константам присваивать, как и почти любому литералу.  
```
int& f(int x){
	int y = x *2;
	return y;
}
```
Мы возвращаем ссылку на локальную переменную, а ссылка указывает на мертвый объект, поэтому если сделать int x = f(0); то это будет UB.  
Это называется проблема битой ссылки, *dangling reference*

Как ссылки устроены? На низком уровне они хранятся как указатели, и это только на низком уровне  

## 2.5 Constants

```
const int x = 1; // такой же тип, но с меньшим количеством определенных на нем операций, определены только «константные операции»
const string s = "abc";
string ss = s; // новый объект
string& ps = s; // так нельзя 
const string& rs = ss; // а так можно
size_t find(string& text, string& word){
	return 0;
}
```
Хотим найти подстроку в строке. Но если вызывать от const string, то будет CE, поэтому надо принимать от константной ссылки  
```
size_t find(const string& text, const string& word){
	return 0;
}
```
При этом если функция от int, то ее не надо по ссылке передавать, так как копирование (4 байта) дешевле ссылки (8 байт), а во всех остальных случаях надо (в строках)  

При этом нельзя `int& x = 1;` тк это rvalue но можно `const int& x = 1;` (с интом то ладно)  

`const string& word = «a»;`
Но тут могла бы быть проблема, тк «a» должен сразу уничтожаться, поэтому делают специально сделали новое правило, что объект уничтожиться, когда имя выйдет из области видимости (объект - вспомогательный объект типа string). А это нужно чтобы мочь вызывать `f(s, «abc»);`  
```
const string& f(const string & s){
	return s;
}
std::cout << f(«abc»);
```

Будет UB, потому что это битая ссылка, которая разрушается при выходе из функции  
```
int a = 1;
const int* p = &a; // так можно, но в обратную сторону нельзя
++p;               // так можно, тк p указывает на константный int
int* const cp = &a;
*pc = 1;           // можно потому что указатель на int
//++cp;            // так нельзя, потому что константный указатель
const int* const ccp = p; // константный указатель на константу
```
И нельзя сделать так:
```
int x = 0;
const int&y = x;
//int&z = y; // тк y уже ссылка на константу
++x;         // поменяется и y тоже
```
## 2.6 Casts
```
// C-style cast
double d = 0.0;
int x = (int) d;
```

1. `static_cast` - просто приведение типов, 
`static_cast<double>(x);`
2. `reinterpret_cast` - берет байты памяти и интерпретирует как байты другого типа
```
double d = 3.14;
std::cout << reinterpret_cast<int*&>(d);
```
Оно выведет интерпретацию этих байт в инте, но это все UB  

3. `const_cast`
`const_cast<const_int&>(n);` трактуем ту же переменную как константу, не создает нового, так можно  
`const int& cn = n;`
`const_cast<int&>(cn);` позволяет снять константность с объекта

4) `c-style cast`
`(int)x` Самый плохой каст, так не надо делать

# III. OOP basics: classes and structures.
## 3.1 Concepts of class and struct, incapsulation
```
class MyClass {
private:
	int x = 0;
	char* p = nullptr;
	std::vector<int> v;
	//fields

public:
	void print(int a){
		std::cout << x + a << '\n';
	} 
	\\methods
	void p(int a);
};
```
Данные в классе - поля, функции - методы
```
int main(){
	MyClass mc;
	mc.print(1);
}
```
`struct` - как класс, но по умолчанию у него все публично
```
void MyClass::p(int a){
	std::cout << x + a;
}
```
