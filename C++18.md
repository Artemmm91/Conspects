## 10.8 Scoped allocators

```cpp
int main() {
    std::vector<std::string, MyAllocator> v;
}
```

Таким образом вектор выделятся будет своим аллокатором, а строки стандартным. Если хотим свой аллокатор и для элементов вектора:

```cpp
int main() {
    using MyVector = std::vector<int, MyAllocator<int>>;
  
    std::vector<MyVector, MyAllocator<MyVector>> v;
    v.push_back(MyVector(1));
}
```
------


```cpp
int main() {
    using MyVector = std::vector<int, MyAllocator<int>>;
    
    MyAllocator<MyVector> outer_alloc;
    MyAllocator<int> inner_alloc(outer_alloc);
    
    std::vector<MyVector, MyAllocator<MyVector>> v(inner_alloc);
    
    v.push_back(MyVector(1));
}
```

А теперь у нас есть контейнер из контейнеров. Но мы хотим чтобы элементы внутреннего контейнера создавалася внешним аллокаторо - чтобы например в тот же пулл их клали.  
Так как написано не получится - придется каждый раз передавать нужный аллокатор.  
Для этого нужен класс `scpoed_allocator_adaptor`


```cpp
#include <scoped_allocator>

int main() {
    using MyVector = std::vector<int, MyAllocator<int>>;
    
    MyAllocator<MyVector> outer_alloc;
    //MyAllocator<int> inner_alloc(outer_alloc);
    
    std::Vector<MyVector, std::scpoed_allocator_adaptor<
        MyAllocator<MyVector>, MyAllocator<int>>> v(outer_alloc);
    
    std::vector<MyVector, MyAllocator<MyVector>> v(inner_alloc);
    
    v.push_back(MyVector(1));
}
```
В scoped_allocator передаем вначале внегний аллокатор, потом внутренний. И создаем вектор от внешнего аллокатора. Как только кладем в вектор элементы - будет сконструирован аллокатором, который будет копией внешнего - то есть из внутреннего создаст внешний.  
У scoped_allocator есть функция construct - 

```cpp
temaplte<typename OuterAlloc, typename... InnerAlloc>
struct scoped_allocator_adaptor: public OuterAlloc {
private:
    scoped_allocator_adaptor<InnerAlloc..., inner_alloc;
public:
    template <typename T, typename... Args>
    void constructor(T* ptr, const Args&... args) {
        if (/* elemets of type T can be created with instance of InnerAlloc */) {
            new(ptr) T(Args..., inner_aloc);
        } else {
            new(ptr) T(args...);
        }
    }
};
```
Здесь inner_alloc - аллокатор предназначенный для внутреннего контейнера, но который стал копией внешнего аллокатора на каком-то этапе. 

В C++17 придумали - polymorphic_allocator - которому не нужен шаблонный тип, он общий для всех (в прицнипе так было бы лучше). А аллокатор создается из memory_resource (напрмиер пул памяти). А дальше он уже сам решает какой тип нужен.

## 10.9 Alignments

Alignment - минимальная степень двойки, такая что только с адресов кратных этой степени двойки можно класть объект этого типа - выравнивание.

Выравнивание структуруы - выравнивание наибольшого поля 

```cpp
struct S {
    int x;
    double y;
    int z;
}

int main() {
    std::cout << sizeof(S);
}
```
Будет 24 байта: 4 на инт, 4 на выравнивание дабла, 8 на дабл, 4 на инт и 4 на выравнивание структуры (чтобы заканчивалась делящимся на 8).  

`std::cout << alignof(S);` - как раз минимальная степень двойки, чтобы положить. Здесь 8 (потому что дабл).

Можно написать:

```cpp
struct alignas(8) S {
    int x;
    int y;
};
```

Проблема может быть такая: когда в аллокаторе вызывается `new(count * sizeof(T))` может быть не учтено выравнивание. Правда malloc умная функция и выделит с учетом выравнивания для стнадартных типо (обычно это 8 байт, но мб и больше) - `std::max_align_t`. 

Но проблема может быть если мы собственноручно сделали alignas больше чем максимальный в стандарте, и тогда будет UB.  

Есть `aligned_alloc` - в который выравнивание: `aligned_alloc(alignof(S), n)` - в операторе new. 

Это бывает нужно если есть мощный комп и за одну процессорную инструкцию можно сделать действие - за раз 32байтное число, или сделать операцию сразу с 4 8-байтными числами. Или наоборот для char можно ходить выравнивание 1. 





















