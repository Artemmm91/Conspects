## 15.4 Capture of this.

```cpp
struct S {
    int a = 5;
  
    void method() {
        auto f = [](int x) {
            return x + a;
        };
    }
};
```
Нвходясь внутри метода класса, в лямбда функции, поля класса не видны. 
И это хорошо, потому что иначе было опасно: в теле функции используется переменная, которая относится к классу, и если фнукция переживает объект класса, то это был бы UB.

Но при этом нельзя написать `auto f = [a](int x)`, потому что таким образом можно захватить только локалные переменные, а `a` не локальная.  
Чтобы использовать, нужно написать так: 

```cpp
struct S {
    int a = 5;
  
    auto get_func() {
        auto f = [this](int x) {
            return x + a;
        };
        return f;
    }
};

int main() {
    auto f = S().get_func();
    f(5);
    return 0;
}
```

То есть теперь мы захватываем указатель на объект класса. И теперь `sizeof(f)` будет равен 8, потому что в полях f лежит указатель.  
При этом в таком коде это UB! Поэтому либо мы не используем поля класса, либо быть уверенным в том что лямбда функция не переживет объект класса. 


## 15.5 Default-capture and capture with initialization


```cpp
struct S {
    int a = 5;
  
    auto get_func(int y) {
        auto f = [a = y, b = a](int x) {
            return x + a;
        };
        return f;
    }
};
```

Такая запись означает, что создается переменная с соответствующим именем, и ей присвается соответствующее значение - как в списках инициализации.  
Теперь не будет UB. Можно было сделать `auto f = [&a = a]` но теперь это опять UB.

Если в полях есть тяжелый обхект, например string, тогда по копии передавать не надо, и по ссылке (потому что будет UB).  
Можно сделать тогда так: `auto f = [s = std::move(s)]...` то есть переменная s заберется в лямбду функцию и будет хранится как копия.

---

Default capture

```cpp
int i = 1;
std::string ss = "xxx";
{
    std::string s = "abcde";
    auto g = [=](){ std::cout << s[i] << '\n';
    
    g();
    
}
```

Такой синтаксис позволяет скопировать все элементы по значению. Также можно сделать `[&]` чтобы захватить все по ссылке.  
Это плохо, потому что в большом коде захватывает очень много переменных, и если они по ссылке, то проблема возникнет при попытке обращаться к переменной которая уже умерла мб, и это UB. Ну и дофига памяти конечно.

Теперь можно и в лямбду захватывать константную ссылку:

```cpp
auto f = [i, &s = std::as_const(s)]() {};
```
as_const - возвращает константную ссылку на объект.

Существуют также обощенные лямбда функции.

```cpp
std::vector<std::string> v{"abc", "abcde"};
std::sort(v.begin(), v.end(), [](const_auto& x, const_auto& y) { return x[0] < y[0]; });
```

Как это работает? Теперь компилятор сгенерирует шаблонный класс с двумя параметрами. и дальше уже вызывается от конкретных типов. 

## std::function

std::function с данными шаблонными параметрами - это такой тип, котоырй может быть проинициализирован любым объектом который можно вызвать от таких кпарамтеров как сказано, и возвращающйи то что сказано. 

```cpp
#include <functional>

bool greater(int x, int y) {
    return x > y;
}

struct Equal {
    bool operator()(int x, int y) const {
        return x == y;
    }
};

struct S {
    bool not_equal(int x, int y) const  {
        return x != y;
    }
};

int main() {
    std::function<bool(int, int)> f = [](int x, int y) {return x < y;};
    std::cout << f(1, 2) << "\n";
    f = &greater;
    f = greater;
    f = Equal();
    std::function<bool(const S&, int, int)> ff = &S::not_equal;
}
```
В этом месте разрешены неявные касты. С сишными функциями можно не писать укзаатель при присвоении.  
То есть можно присваивать сишную функцию, лямбда функцию, функциональный объект (структура с методом ()), и метод класса (но надо быть аккуратным с парамтерами - первым идет структура).

