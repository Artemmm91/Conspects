# XI. Containers
## 9.1 Vector implementation

```
template <typename T>
class Vector {
private:
    T* arr;
    size_t sz;
    size_t cap;
public:
    // size_t size() const;
    // size_t capacity() const;
    
    void reserve(size_t n) {
        if (n <= cap) retur;
        T* newarr = new T[n];
        for(size_t i = 0; i < sz; ++i) {
            newarr[i] = arr[i];
        }
        delete[] arr;
        arr = newarr;
        cap = n;
    }
    
    void resize(size_t n, const T& value = T()) {
        if (n > cap) reserve(n);
        for (size_t i = sz; i < n; ++i) {
            arr[i] = value;
        }
        if (n < sz) {
            sz = n;
        }
    }
    
    void push_back(const T& value) {
        if (cap == sz) {
            reserve(2 * sz);
        }
        arr[sz] = value;
        ++sz;
    }
    
    void pop_back() {
        --sz;
    }
};

int main() {
    std::vector<int> v(10);
    
    v.size();
    v.capacity();
}
```
Просто так нельзя делать `T* newarr = new T[n];` потому что объекты может это потоки или другой объект захватывающий ресурс. Функция `reserve` должна резервировать а не пересоздавать.  

Вместо этого напишем `T* newarr = reinterpret_cast<T*>(new byte[n * sizeof(T)]);` по сути мы как раз и выделим сколько нужно памяти.  

Также плохо писать `newarr[i] = arr[i];` потому что теперь нет объекта в `arr[i]`, и используется оператор присваивания из ничего. Надо ` new (newarr + i) T(arr[i]);` - конструктор по такому адресу - placement new  

Также плохо сделать `delete[] arr;` потому что он будет удалять деструктором те объекты которые еще не были созданы конструктором, при этому непонятное количество. Надо писать
```
for (size_t i = 0; i < szl ++i) {
    (arr + i)->~T();
}
delete[] reinterpret_cast<byte*>(arr);
```

Что еще в `push_back` не то? Он не безопасен относительно исключений (как впрочем и другие функции).  

*Базовая гарантия исключений* - контейнер остается в валидном состоянии при выкидывании исключения.  
*Строгая гарантия исключений* - контейнер остается в неизменном  состоянии при исключении.  

А сейчас если будет исключение в середине функции, то будет очень плохо, функции не доделаются. Надо разобратсья со всеми случаями, кроме исключений в деструкторах.  

```
size_t i = 0;
try {
    for (; i < sz; ++i) {
        newarr[i] = arr[i];
    }
} catch(...) {
    for (size_t j = 0; j < i; ++j) {
        (newarr + i)->~T();
    }
    delete[] reinterpret_cast<byte*>(newarr);
    throw;
}
```
И так надо со всеми сделать. Но можно короче сделать так:
```
try {
    std::uninitialized_caopy(arr, arr + sz, newarr);
} catch(...) {
    delete[] reinterpret_cast<byte*>(newarr);
    throw;
}
```
Тут функция делает примерно ровно то что нужно.  
Еще исключение может бросить `new` броисв `bad_alloc` при большом выделении памяти, но с ней ничего не надо делать, она сама бросит исключение и ничего удалять не надо.  

Чем плох `&(*(iterator))` в отличие от `std::adressof(*iterator)`? Потому что может быть перегружен опертор `&` для данного типа.  

```
void pop_back() {
   --sz;
   (arr + sz)->~T();
}

T& operator [](size_t i) {
    return arr[i];
}
// const T& operator [](size_t i) const;

T& operator at(size_t i) {
    if(i >= sz) {
        throw std::out_of_range("...");
    }
    return arr[i];
}
// const T& operator at(size_t i) const;
```

Еще раз: `new` - выделяет память и вызывает констурктор, `placement_new` - конструктор по адресу но НЕ выделяет память. 

## 9.2 Boolean vector

Особенность - памяти тратится меньше - он пакует були, чтобы вместо 1 байта они занимали 1 бит.

```
tempalte <>
class Vector<bool> {
private:
    uint8_t* arr;

    struct BitReference {
        uint8_t* bucket_ptr;
        uint8_t pos;
        
        BitReference& operator=(bool b) {
            if (b) {
                *bucket_ptr |= ((uint8_t)1 << pos);
            } else {
                *bucket_ptr &= ~((uint8_t)1 << pos);
            }
            return *this;
        }
        
        operator bool() const {
            return *bucket_ptr & (1 << pos);
        }
    };
public:
    
    BitReferece operator[](size_t i) {
        uint8_t pos = i % 8;
        uint8_t* ptr = arr + i / 8;
        return BitReference(ptr, pos);
    }
};
    
    
template <typename T>
class C {
    temaplte <typename U>
    C(const U&) = delete;
};
  
int main() {
    std::vector<bool> vb(10);
    C c(vb[5]);
    
    const bool& k = vb[5];
    // bool& k = vb[5]; <- нельзя, не кастуется 
}
```

Если применим такой трюк, то компилятор скажет, что тип `vb[5]` это `std::_Bit_reference`.
    
