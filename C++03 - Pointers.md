# II. Pointers, arrays, functions, references, constants etc
## 2.1) Pointers and kinds of memory

У каждой переменной есть адрес. В плюсах есть возможность обращаться к памяти по ячейкам (но это абстракция).
```cpp
int x;
int* p = &x;  // адрес переменной x, имеет специальный тип для хранения адресов int*
*p;           // разыменовывание, смотрит адрес возвращает значение int
```
То есть функция `&: int -> int*`    при этом  `*:  int* -> int`  
При этом можно делать указатель от указателя  
Можно складывать указатели с числами `+ :  (T*, int) -> T*  (int, T*) ->T*`  
Потому что по сути T* - 16-ричное число с адресом `(sizeof(int*) == 8)`
При это сложение работает так: `p + x * sizeof(T)`
Например: 
```cpp
int* p = 0x00001f42;
//p + 3== 0x00001f4e
```

Аналогично вычитание из указателя число (не наоборот), также можно вычитать указатели `(T*, T*)->int64_t` (при этом это разность деленная на 4)  

Есть особый тип `void*` - просто адрес памяти непонятно на что, абстрактный указатель. 
И он не допускает прибавления и разности с ним(по крайней мере warning). Разыменовывать его нельзя.  
`nullptr` - нулевой указатель (при этом имеет свой тип `nullptr_t`), при разыменовании UB.   

Как устроено в памяти: `[data, text, stack]`, где text - исполняемые команды, инструкции, data - данные, которые в программе статические (static memory), глобальные переменные, stack - место для локальных переменных (automatic memory, 4 MB).  
```cpp
void f(){
    static int count = 0;  //статическая переменная, один раз проинициализировалась, 
                           //и доступна в функции каждый раз, но при этом область видимости - только эта функция
    ++count;
}
```
При этом в стеке хранятся не только переменные, но и функции (адрес возврата функции), при это локальные переменные стираются при выходе из одной области.  

-----

### Распределение памяти

`int* p = new int(5);`  <- new(унарный оператор) просит (4 байта) памяти (он сразу проинициализировался значением 5 (если оставить пустые скобки - то 0 будет) и указывает место где доп память начинается, и new возвращает указатель.  
Вне своей видимости не существует, указатель удалиться, но сами данные там и остануться, чтобы такого не было есть delete p; 
Всегда когда идет обращение к памяти которая не была выделена, то это UB (а на практикетчс seg fault)  

Garbage colletion - в джаве собирает неудаленные перемены  
Отличие плюсов от джавы - в том что можно самим память распределять  
```cpp
int f(){
    int* p = new int(5);
    int* pp = new int(6);
    delete p, pp;
}
```
Удалиться только p, тк delete унарный оператор и его можно делать только с new;  

## 2.2 Arrays

`int a[100];`  

В стеке отнимается 400 байт, которые называются а. У а тип массив из 100 элементов. Главная операция массива  - указатель на нулевой элемент.  
```cpp
int* p = a; // array-to-pointer conversion
a[1] = 2; // equivalent yo *(a + 1) = 2;
p[2] = 3;
p[-1] = 1; // а это уже обращение к предыдущему и в данном случае UB
5[p] = 1; // то же что *(5 + p) = 1;
```
Массивы от указателей отличаются следующим: для массивов запрещено присваивание массивов, а также присваивание массиву указатель  

При этом sizeof(a) = 400, sizeof(p) = 4  
Динамическое выделение:  

`int*p = new int[100];`  оператор `new[]` 
И здесь p - указатель на new int  

`int (* (*)[10])[10];` массив 10 указателей на указатель длины 10  
`int (*)[10][10];` указатель массива 10 массивов

`delete[] p;` удаление, при этом ему нужно знать размер, поэтому при `new[100]` он дает не 400 памяти, а 417, чтобы хранить размер дополнительно.

## 2.3 Function and pointers to functions
```cpp
T f(int, int){}

int main(){
    T (*pf)(int, int)= &f;
}
```
Объявление указателя на функцию. Типо pf будет `T(*)(int, int)`  
Указателям можно присваивать указатели других функций.

### Functions overloading

Название функций одинакового, а аргументы разные, при этом адреса разные и в разных местах кода лежат  
```cpp
void f(int) {std::cout << 1;}
void f(double){std::cout << 2;}
void f(long long) {std::cout << 3;}

int main(){
    f(0); // 1
    f(0ll); // 3
    f(0.0); // 2
    f(0.0f); // 2
}
```
**Overloading resolution** - компилятор решает какую функцию выбрать, и может быть разные варианты, так например он делает наибольшее «лучший» вариант неявного преобразования типов, при это это «лучше» сложно описывается в стандарте, в общем: если она короче и дешевле (расширение типов(int в ll) лучше чем приведение, а приведение лучше чем пользовательское приведение). Но если непонятно то CE  
```cpp
void f(float){}
void f(int){}

int main(){
    f(0.0);
}
```
Ему равнозначно в какой тип приводить, поэтому ошибка неоднозначности  

Пример:
```cpp
int f(double){}
double f(int){}

int main(){
    f(0); // будет вторая функция вызвана
}
```
Перегрузка только по принимаемым аргументам! И не смотрит что возвращает
