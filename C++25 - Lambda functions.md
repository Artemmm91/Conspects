# XV. Lambda functions and elements of functional programming

## 15.1 General idea, basic syntax

```cpp
struct MyCompare {
    bool operator()(int x, int y) const {
        return std::abs(x - 5) < std::abs(y - 5);
    }
};

std::vector<int> v{1, 5, 4, 7};
std::sort(v.begin(), v.end(), MyCompare());
```
Основное неудобство - приходится объявлять функцию/компаратор снаружи области видимости - нарушение инкапсуляции.

```cpp
std::sort(v.begin(), v.end(), 
    [](int xm int y) {
        return std::abs(x - 5) < std::abs(y - 5);
    });
```

Сейчас все делают так: базовый синтаксис - объявление `[]` - closure expression, дальше параметры, дальше тело функции.

```cpp
auto f = [](int x, int y) {
            return std::abs(x - 5) < std::abs(y - 5);
        };
std::sort(v.begin(), v.end(), f);
```
Можно также сделать это переменной.
Лямбда-функция - это expression, rvalue. Но непонятно какого типа.
 
```cpp
[](int x) {
   std::cout << x << "\n";
}(5);
```
Здесь мы мгновенно создаем и вызываем функцию.  

Тип возвращаемого значения определяется автоматически, но если возвращаемый тип может зависеть от условий, то можно указать тип.
```cpp
auto f = [](int x, int y) -> bool {
            if (x == y)
                return x + y;
            return std::abs(x - 5) < std::abs(y - 5);
        };
```
Функция возвращающая лямбда функцию:
```cpp
auto get_compare() {
    return [](int x, int y){ return x*x < y*y; };
}

std::sort(v.begin(), v.end(), get_compare());
```

## 15.2 Capture lists in lambda functions

```cpp
int a = 1;

[](int x) {
   std::cout << x + a << "\n";
}(5);
```

Будет CE потому что `a` не захвачен внутрь лямбда-функции, локальные объекты не попадают в область видимости, в отличие от глобальных или конкретных namespace. 

Надо было написать так

```cpp
int a = 1;

[a](int x) {
   std::cout << x + a << "\n";
}(5);
```

Но так нельзя будет менять переменную `a` - ее тип const int. Чтобы можно было менять надо написать так:

```cpp
[a](int x) mutable {...};
```

Но переменная внешняя не поменяется при изменении локальной. А если мы хотим то надо захватывать по ссылке:

```cpp
[a](int x) {
   std::cout << x + a << "\n";
   ++a;
}(5);
```
Однако здесь тип а - int& !

```cpp
auto f = [](int x, int y){...};
std::map<int, int, decltype(f)> m;
```

## 15.3 Lambda functions as objects

```cpp
template <typename T>
void g(const T&) = delete;

int main() {
    auto f = [] (int x, int y) {
        return x < y;
    }
    g(f);
}
```

Тип будет какой-то странный.

Как это работает? Компилятор превращает функцию в класс с каким-то названием, и внутри есть метод () который равен нашей функции, а дальше при использовании подставляет в код. Соответственно размер sizeof(f) тогда будет 1, так как нет полей.

А если бы делали захват, то компилятор параметр положил бы в поле, и тогда размер бы зависел от параметров.

Компилятор делает метод константным, и поля соответственно тоже, поэтому если передавать по значению будет const тип, а на ссылки это не распространяется. Поэтому если написать mutable, то можно будет изменять. 

Замечание:

```cpp
struct S{
    int& a;
    
    void f() const {
        ++a;
    }
};
```

Ошибок не будет, так как это поле по сслыке - компилятор делает int& const, из ключевого слова для функции, и изменять можно будеть.

По сути лямбда функции это структуруы, поэтому можно мувать, создавать одун из другой, но оператора присваивания нет - хотя он и не нужен. 

В c++20 появилось следующее:

```cpp
decltype(f) ff;
```

То есть дефолтный конструктор появился. Но если есть захват какой-то, то конструктор по умолчанию не сработал бы. 





